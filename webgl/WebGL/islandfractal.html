<!DOCTYPE html><html lang='en' class=''>
<script id="vertex-shader" type="x-shader/x-vertex">
  attribute vec2 aVertexPosition;

  uniform vec2 uScalingFactor;
  uniform vec2 uRotationVector;
  uniform vec2 resolution;

  void main() {
    vec2 rotatedPosition = vec2((aVertexPosition.x),
      (aVertexPosition.y)
    );

    gl_Position = vec4(rotatedPosition * uScalingFactor, 0.0, 1.0);
  }
</script>
<script id="fragment-shader" type="x-shader/x-fragment">
  #ifdef GL_ES
    precision highp float;
  #endif
  uniform float time;
  uniform vec2 resolution;

  vec2 fc(vec2 z, vec2 c) {
    //return vec2(z.x*z.x-z.y*z.y+c.x, z.x*z.y+z.y*z.x+c.y);
    return vec2(abs(z.x*z.x-z.y*z.y+c.x), abs(z.x*z.y+z.y*z.x+c.y));
  }

  vec2 p50valueAt(vec2 pos) {
    vec2 z = vec2(0.0,0.0);
    for (int j = 0; j < 50; j += 1){z = fc(z, pos);}
    return vec2(z);
  }

  vec2 p5valueAt(vec2 pos) {
    vec2 z = vec2(0.0,0.0);
    for (int j = 0; j < 5; j += 1){z = fc(z, pos);}
    return vec2(z);
  }

  float waves(vec2 pos) {
    return mod(sin(sin(pos.x*1000.0/2.0)*2.0+sin(time/10.0+pos.x*1000.0)+pos.y*1000.0)/10.0,0.5);
  }

  void main() {
    float t = time/10.0*0.0+30.0;
    float zoom = 2000.0-1000.0*(cos(t/70.0)/2.0+cos(t/16.18)/5.0+sin(t/70.0)/2.0+sin(t/16.18)/5.0);
    vec2 pos = vec2((gl_FragCoord.x-resolution.x/2.0)/zoom-0.5+cos(t/70.0)/2.0+cos(t/16.18)/5.0, (gl_FragCoord.y-resolution.y/2.0)/zoom-0.5+sin(t/70.0)/2.0+sin(t/16.18)/5.0);
    vec2 z0 = p5valueAt(pos);
    float c = 0.0;
    float c2 = 0.0;
    float c3 = 0.0;
    if (z0.x < 100.0 && z0.y < 100.0) {
      vec2 z = p50valueAt(pos);
      if (z.x < 100.0 && z.y < 100.0) {
        c = (z.x < 2.0/3.0 && z.y < 2.0/3.0) ? z.x+z.y: 0.0;
        c2 = (z.x < 100.0 && z.y < 100.0) ? z.x+z.y+0.5: 0.0;
      } else {
        vec2 z2 = p5valueAt(vec2(pos.x/(sin(time/50.0)/3.0+1.0), pos.y/(sin(time/50.0)/3.0+1.0)));
        vec2 z3 = p5valueAt(vec2(pos.x/(sin(time/50.0+3.1415)/3.0+1.0), pos.y/(sin(time/50.0+3.1415)/3.0+1.0)));
        c3 = (z2.x < 100.0 && z2.y < 100.0) ? waves(pos)+0.5: waves(pos);
        c3 = (z3.x < 100.0 && z3.y < 100.0) ? c3: c3-waves(pos)/2.0;
      }
    } else {
      vec2 z2 = p5valueAt(vec2(pos.x/(sin(time/50.0)/3.0+1.0), pos.y/(sin(time/50.0)/3.0+1.0)));
      vec2 z3 = p5valueAt(vec2(pos.x/(sin(time/50.0+3.1415)/3.0+1.0), pos.y/(sin(time/50.0+3.1415)/3.0+1.0)));
      c3 = (z2.x < 100.0 && z2.y < 100.0) ? waves(pos)+0.5: waves(pos);
      c3 = (z3.x < 100.0 && z3.y < 100.0) ? c3: c3-waves(pos)/2.0;
    }

    //float c3 = (z.x < 100.0 && z.y < 100.0) ? mod(floor(pos.x*4.0)+floor(pos.y*4.0), 2.0): mod(floor(pos.x*4.0)+floor(pos.y*4.0)+1.0, 2.0);
    vec3 color = vec3(c, c2, c3);
    //color = (floor(mod(pos.x,1.0)*mod(pos.y,1.0)*1000.0) == 0.0) ? vec3(1.0,1.0,1.0) : color;
    gl_FragColor = vec4(color.r,color.g,color.b,1.0);
    //gl_FragColor = vec4(cos(gl_FragCoord.x/1000.0+time/9.0)/2.0+0.5,sin(gl_FragCoord.y/1000.0+time/10.0)/2.0+0.5,sin((gl_FragCoord.x-resolution.x/2.0)/(gl_FragCoord.y-resolution.y/2.0)+time/11.0)/2.0+0.5,1.0);
  }
</script>

<style>
  /* remove the border */
  body {
    margin: 0 !important;
    padding: 0 !important;
    border: 0;
    background-color: "#685436";
  }
  /* make the canvas the size of the viewport */
  canvas {
    width: 100vw;
    height: 100vh;
    display: block;
  }
</style>
<body>
<canvas id="glcanvas">
  Oh no! Your browser doesn't support canvas!
</canvas>
</body>
<script>
let gl = null;
let glCanvas = null;

// Aspect ratio and coordinate system
// details

let aspectRatio;
let currentRotation = [0, 1];
let currentScale = [1.0, 1.0];

// Vertex information

let vertexArray;
let vertexBuffer;
let vertexNumComponents;
let vertexCount;

// Rendering data shared with the
// scalers.

let uScalingFactor;
let uGlobalColor;
let uRotationVector;
let aVertexPosition;

// Animation timing

let previousTime = 0.0;
let degreesPerSecond = 90.0;

window.addEventListener("load", startup, false);

function resize(canvas) {
  var realToCSSPixels = window.devicePixelRatio;

  // Lookup the size the browser is displaying the canvas in CSS pixels
  // and compute a size needed to make our drawingbuffer match it in
  // device pixels.
  var displayWidth  = Math.floor(gl.canvas.clientWidth  * realToCSSPixels);
  var displayHeight = Math.floor(gl.canvas.clientHeight * realToCSSPixels);
  // Check if the canvas is not the same size.
  if (canvas.width  != displayWidth ||
      canvas.height != displayHeight) {

    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
}

function startup() {
  glCanvas = document.getElementById("glcanvas");
  gl = glCanvas.getContext("webgl");

  const shaderSet = [
    {
      type: gl.VERTEX_SHADER,
      id: "vertex-shader"
    },
    {
      type: gl.FRAGMENT_SHADER,
      id: "fragment-shader"
    }
  ];

  shaderProgram = buildShaderProgram(shaderSet);

  aspectRatio = glCanvas.width/glCanvas.height;
  currentRotation = [0, 1];
  currentScale = [1.0, glCanvas.width/glCanvas.height];

  vertexArray = new Float32Array([
    1,-1,
    -1,-1,
    -1,1,
    1,-1,
    1,1,
    -1,1,
  ]);

  vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);

  vertexNumComponents = 2;
  vertexCount = vertexArray.length/vertexNumComponents;

  currentAngle = 0.0;
  rotationRate = 1;
  time = 0.0;

  animateScene();
}

function buildShaderProgram(shaderInfo) {
  let program = gl.createProgram();

  shaderInfo.forEach(function(desc) {
    let shader = compileShader(desc.id, desc.type);

    if (shader) {
      gl.attachShader(program, shader);
    }
  });

  gl.linkProgram(program)

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.log("Error linking shader program:");
    console.log(gl.getProgramInfoLog(program));
  }

  return program;
}

function compileShader(id, type) {
  let code = document.getElementById(id).firstChild.nodeValue;
  let shader = gl.createShader(type);

  gl.shaderSource(shader, code);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.log(`Error compiling ${type === gl.VERTEX_SHADER ? "vertex" : "fragment"} shader:`);
    console.log(gl.getShaderInfoLog(shader));
  }
  return shader;
}

function animateScene() {
  resize(gl.canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  currentScale = [1.0, glCanvas.width/glCanvas.height];
  gl.clearColor(0.666, 0.666, 0.666, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  let radians = currentAngle * Math.PI / 180.0;
  currentRotation[0] = Math.sin(radians);
  currentRotation[1] = Math.cos(radians);

  gl.useProgram(shaderProgram);

  uScalingFactor =
      gl.getUniformLocation(shaderProgram, "uScalingFactor");
  uRotationVector =
      gl.getUniformLocation(shaderProgram, "uRotationVector");
  utime =
      gl.getUniformLocation(shaderProgram, "time");
  uresolution =
      gl.getUniformLocation(shaderProgram, "resolution");


  gl.uniform2fv(uScalingFactor, currentScale);
  gl.uniform2fv(uRotationVector, currentRotation);
  gl.uniform1f(utime, time);
  gl.uniform2fv(uresolution, [glCanvas.width, glCanvas.height]);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

  aVertexPosition =
      gl.getAttribLocation(shaderProgram, "aVertexPosition");

  gl.enableVertexAttribArray(aVertexPosition);
  gl.vertexAttribPointer(aVertexPosition, vertexNumComponents,
        gl.FLOAT, false, 0, 0);

  gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

  window.requestAnimationFrame(function(currentTime) {
    let deltaAngle = ((currentTime - previousTime) / 1000.0)
          * degreesPerSecond;

    currentAngle = (currentAngle + deltaAngle) % 360;
    time = time+1.0
    previousTime = currentTime;
    animateScene();
  });
}

</script>

</html>
